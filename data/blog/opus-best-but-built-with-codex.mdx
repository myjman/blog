---
title: 'Opus가 최고라면서 왜 Codex로 만들었나'
date: '2026-02-14T18:00:00'
tags:
  [
    'openclaw',
    '오픈클로',
    'claude-opus',
    '클로드오퍼스',
    'codex',
    '코덱스',
    'ai-coding',
    'AI코딩',
    'vibe-coding',
    '바이브코딩',
  ]
draft: false
images: ['/static/images/opus-best-but-built-with-codex/og-image.jpg']
summary: 'OpenClaw 창시자 Peter Steinberger는 Claude Opus를 최고의 범용 에이전트라고 말하면서도, 정작 OpenClaw는 Codex로 만들었다. 모순일까, 통찰일까.'
---

## 18만 스타의 남자가 남긴 모순

![AI 로봇의 얼굴 — 어떤 모델이 최고인지는 사람마다 다르다](/static/images/opus-best-but-built-with-codex/og-image.jpg)

2026년 2월, GitHub 역사상 가장 빠르게 성장한 프로젝트가 등장했다. OpenClaw다. 오스트리아 출신 개발자 Peter Steinberger가 만든 오픈소스 AI 에이전트다. 18만 개 이상의 스타를 기록했다. 1월 한 달 동안 6,600개의 커밋이 올라갔다. 한 사람이 만든 프로젝트다.

그런데 이상한 점이 있다. Steinberger는 Anthropic의 Claude Opus를 **"최고의 범용 에이전트"**라고 공개적으로 말했다. OpenClaw 사용자들에게도 Claude Opus를 추천한다. 그런데 정작 OpenClaw를 만들 때는 OpenAI의 Codex를 사용했다.

이게 모순일까? 아니면 우리가 놓치고 있는 뭔가가 있는 걸까?

---

## OpenClaw란 무엇인가

OpenClaw는 자율형 AI 에이전트다. 사용자가 지시를 내리면, AI가 스스로 작업을 수행한다. 코드를 짜고, 파일을 만들고, 테스트를 돌리고, 배포까지 한다. 사람이 중간에 개입하지 않아도 된다.

원래 이름은 Clawdbot이었다. Anthropic의 Claude를 연상시키는 이름이다. 2026년 1월 27일, Anthropic의 상표권 클레임을 받고 Moltbot으로 바꿨다. 하지만 이 이름이 입에 잘 붙지 않아서, 3일 만에 다시 OpenClaw로 변경했다.

OpenClaw는 특정 AI 모델에 종속되지 않는다. **모델 애그노스틱(model-agnostic)**이다. Claude Opus 4.6, GPT Codex 5.3, DeepSeek, 심지어 로컬에서 돌리는 오픈소스 모델까지 지원한다. 사용자가 원하는 모델을 선택할 수 있다.

그런데 Steinberger 본인은 OpenClaw를 **만들 때** Codex를 사용했다. 사용자에게는 Opus를 추천하면서. 왜?

---

## "Opus가 최고"라고 말한 이유

![코드가 흐르는 화면 — AI 코딩 도구의 시대](/static/images/opus-best-but-built-with-codex/coding.jpg)

Steinberger가 Claude Opus를 최고라고 말한 데는 분명한 근거가 있다.

2026년 2월 5일, Anthropic은 Claude Opus 4.6을 출시했다. 같은 날 OpenAI도 GPT-5.3-Codex를 발표했다. 두 모델이 정면으로 충돌한 날이다.

벤치마크 결과를 보면 Opus 4.6의 강점이 드러난다. **Terminal-Bench 2.0**에서 Opus 4.6은 GPT-5.2를 약 144 Elo 포인트 앞섰다. **Humanity's Last Exam**과 **GDPval-AA** 같은 추론 및 지식 작업 벤치마크에서도 상위권이다.

특히 Opus 4.6이 빛나는 영역이 있다. **긴 컨텍스트 처리**, **모호한 제약 조건 해석**, **여러 파일에 걸친 일관성 유지**다. 대규모 코드베이스에서 설계 결정을 내려야 할 때, 정답이 여러 파일에 분산된 상태에서 일관된 구조를 만들어야 할 때, Opus 4.6이 강하다.

프롬프트 인젝션 방어에서도 Opus 4.6이 앞선다. OpenClaw 같은 자율 에이전트에서는 보안이 중요하다. AI가 악의적인 입력에 속아서 의도치 않은 행동을 하면 안 된다. Opus 4.6은 이런 공격에 더 강한 저항력을 보인다.

이런 특성들 때문에 Steinberger는 Opus를 "최고의 범용 에이전트"라고 부른다. **일반적인 사용자가 다양한 작업을 맡길 때**, Opus 4.6이 가장 안전하고 일관된 결과를 낸다는 뜻이다.

---

## 그런데 왜 Codex로 만들었나

여기서 반전이 시작된다.

Steinberger는 OpenClaw를 만들 때 Claude Code가 아니라 Codex를 사용했다. 이유가 뭘까?

The Pragmatic Engineer 뉴스레터에서 Steinberger는 이렇게 말했다.

> "Codex는 장시간 실행 작업에서 중단 없이 진행한다. Claude Code는 명확한 설명을 위해 자주 사용자에게 질문하는 경향이 있어 방해가 된다."

핵심은 **작업 흐름**이다.

Steinberger의 개발 방식은 독특하다. 그는 코드 작성 전에 에이전트와 **계획을 철저히 수립**한다. 에이전트에게 도전하고, 수정하고, 반박한다. 계획이 충분히 다듬어지면 그제서야 실행을 시작한다. 그리고 다음 작업의 계획을 세우러 간다.

이 방식에서 Claude Code는 문제가 된다. Claude Code는 **너무 빠르고, 자주 질문한다**. 작업 중간에 "이게 맞는지 확인해도 될까요?" 같은 질문이 날아온다. 이미 계획을 다 세워놓은 Steinberger에게는 방해다.

반면 Codex는 **조용히 10분 동안 코드를 읽고 나서 장기 작업을 시작**한다. 작은 프롬프트로도 원하는 대로 작동한다. 끼어들지 않는다. Steinberger의 표현을 빌리면, "내성적인 엔지니어처럼 묵묵히 일을 해낸다."

| 특성 | Claude Code | Codex |
| --- | --- | --- |
| 작업 스타일 | 자주 확인, 빠른 반응 | 조용히 진행, 장시간 실행 |
| 계획 수립 후 | 중간에 질문함 | 중단 없이 완료 |
| 적합한 사용자 | 대화형 협업 선호 | 비동기 작업 선호 |
| 코드 읽기 | 빠르게 시작 | 10분 이상 읽고 시작 |

---

## 모순이 아니라 용도의 차이다

![선택의 갈림길 — 어떤 도구를 쓸지는 목적에 달렸다](/static/images/opus-best-but-built-with-codex/paradox.jpg)

이제 Steinberger의 발언이 모순이 아님을 알 수 있다. 그는 두 가지 다른 맥락에서 다른 도구를 추천하고 있다.

**OpenClaw 사용자에게 Opus를 추천하는 이유**: 범용 에이전트로서의 안정성, 보안, 긴 컨텍스트 처리 능력.

**본인이 Codex로 개발하는 이유**: 장시간 비동기 작업에 적합한 작업 흐름.

이건 "뭐가 더 좋으냐"의 문제가 아니다. **"어떤 상황에 뭐가 맞느냐"**의 문제다.

Steinberger는 하루에 600개의 커밋을 올린 적도 있다. 어떻게 가능할까? 그의 방식은 **병렬 실행**이다. 계획을 세우고 Codex에 던지고, 다음 계획을 세운다. 여러 개의 Codex 세션이 동시에 돌아간다. 하나가 끝나면 결과를 확인하고 다음 작업을 시작한다.

이 워크플로우에서 Claude Code의 "확인 요청"은 병목이 된다. 10개의 세션이 돌아가는데 각각이 질문을 던지면, Steinberger는 계속 맥락 전환을 해야 한다. Codex는 그냥 알아서 한다.

하지만 일반 사용자는 다르다. 대부분의 사람들은 AI와 **대화하면서** 작업한다. 계획을 사전에 완벽하게 세우지 않는다. 작업 중간에 "이게 맞아?" 하고 확인받고 싶어한다. 이런 사용자에게는 Opus의 "친절한 확인"이 오히려 장점이다.

---

## 두 모델의 성격 차이

Lex Fridman 팟캐스트에서 Steinberger는 두 모델의 성격을 비교했다. 그의 표현을 빌리면 이렇다.

**Claude Opus 4.6**: 따뜻하고, 빠르고, 허락 없이 일단 해보는 스타일. 사용자 친화적이다. 설명을 잘 해주고, 중간에 확인도 해준다.

**GPT Codex 5.3**: 정밀하고, 철저하고, 끝까지 밀어붙이는 스타일. 한번 시작하면 끝까지 간다. 중간에 끊기지 않는다.

흥미로운 건 2026년 들어 두 모델이 **서로를 닮아가고 있다**는 점이다. Opus 4.6은 Codex의 정밀함을 일부 흡수했고, Codex 5.3은 Opus의 따뜻함을 일부 가져왔다.

하지만 근본적인 차이는 남아 있다. Claude는 **대화형 에이전트**에 최적화되어 있다. Codex는 **비동기 실행 에이전트**에 최적화되어 있다.

Steinberger가 X(트위터)에 남긴 말이 있다.

> "Codex는 조용히 묵묵히 일하는 타입이고, Claude는 마크다운 파일을 수백만 개 만들어내는 게 짜증난다. 인프라/테스트/툴링에는 Claude가 낫지만."

그의 코드베이스에는 Claude Code를 들이지 않는다. Opus로 돌리면 버그가 너무 많다고 한다. 이건 모델의 결함이 아니라 **작업 스타일의 불일치**다.

---

## 벤치마크가 말해주지 않는 것

벤치마크 숫자만 보면 어느 모델이 "객관적으로" 더 좋은지 판단할 수 있을 것 같다. 하지만 현실은 그렇게 단순하지 않다.

**Terminal-Bench 2.0**에서 Codex 5.3은 77.3%를 기록했고, Opus 4.6은 약 65.4%였다. 단순히 숫자만 보면 Codex가 압도적으로 보인다. 그런데 왜 Steinberger는 Opus를 "최고"라고 부를까?

벤치마크는 **특정 조건에서의 성능**을 측정한다. Terminal-Bench는 터미널 기반 코딩 작업을 평가한다. 하지만 실제 업무에서 AI 에이전트가 하는 일은 훨씬 다양하다.

- 긴 문서를 읽고 요약하기
- 모호한 요구사항을 해석하기
- 여러 파일에 걸친 리팩토링
- 보안 취약점 탐지
- 사용자와의 자연스러운 대화

이런 작업에서는 벤치마크 점수가 직접적으로 반영되지 않는다. Opus 4.6이 Humanity's Last Exam 같은 추론 벤치마크에서 앞서는 건, 바로 이런 "범용적" 능력 때문이다.

또 하나 중요한 요소가 있다. **속도와 비용**이다.

50개의 병렬 에이전트 배치를 돌렸을 때, Codex 5.3은 45초 만에 끝냈다. Opus 4.6은 거의 3분이 걸렸다. 처리량(throughput)에서 4배 차이다. 대규모 작업을 돌리는 Steinberger 같은 사용자에게는 이 차이가 치명적이다.

반면 단일 작업의 품질에서는 Opus가 앞설 때가 많다. "이 코드가 왜 문제인지 설명해줘"라는 요청에 Opus는 더 명확하고 구조화된 답변을 내놓는다.

결국 **어떤 작업을 얼마나 하느냐**에 따라 최적의 모델이 달라진다.

---

## OpenClaw가 모델 애그노스틱인 이유

OpenClaw의 설계 철학이 바로 여기서 나온다.

Steinberger는 OpenClaw를 **특정 모델에 종속시키지 않았다**. Claude Opus 4.6, GPT Codex 5.3, DeepSeek, 로컬 모델까지 전부 지원한다. 사용자가 선택한다.

2026년 2월 6일에 출시된 OpenClaw v2026.2.6에서는 Opus 4.6과 GPT-5.3-Codex 지원이 공식적으로 추가되었다. 같은 인스턴스 안에서 **작업별로 다른 모델을 설정**할 수도 있다.

일반적인 전략은 이렇다:
- 일상적인 어시스턴트 작업: Claude Sonnet 4.5 (빠르고 저렴)
- 고위험 작업, 중요한 결정: Opus 4.6 (안정적이고 안전)
- 대량 병렬 코딩: Codex 5.3 (빠른 처리량)

이 설계가 가능한 건 Steinberger가 **직접 겪어봤기 때문**이다. 그는 Opus를 최고의 범용 에이전트라고 생각하지만, 자신의 특수한 작업 흐름에는 Codex가 맞다는 걸 안다. 그래서 OpenClaw 사용자들에게도 "상황에 맞는 모델을 써라"고 말한다.

---

## 말과 행동이 다른 게 아니다

![복잡한 선택 — 정답은 하나가 아니다](/static/images/opus-best-but-built-with-codex/choice.jpg)

처음에는 Steinberger의 발언이 모순처럼 보였다. "Opus가 최고"라면서 왜 Codex로 만들었나?

하지만 깊이 들여다보면 **일관된 철학**이 보인다.

1. **최고의 도구는 상황에 따라 다르다.** 범용성에서 최고인 것과 특정 작업에서 최고인 것은 다르다.

2. **자신의 작업 흐름을 안다.** Steinberger는 자신이 어떻게 일하는지 정확히 알고 있다. 계획을 먼저 세우고, 비동기로 여러 작업을 병렬 실행한다. 이 흐름에는 Codex가 맞다.

3. **사용자는 다르다.** 대부분의 사용자는 Steinberger처럼 일하지 않는다. 대화형으로 AI와 협업한다. 중간 확인이 필요하다. 이런 사용자에게는 Opus가 더 적합하다.

4. **모델은 도구다.** 어떤 모델이 "객관적으로" 더 좋은지 따지는 건 무의미하다. 톱이 망치보다 좋은지 나쁜지 따지는 것과 같다. 뭘 하느냐에 따라 달라진다.

Steinberger의 "모순"은 사실 **가장 솔직한 조언**이다. "나는 이렇게 쓰지만, 너는 다를 수 있다. 네 상황에 맞는 걸 써라."

---

## Steinberger의 작업 방식: 폐쇄 루프 설계

Steinberger가 하루에 600개의 커밋을 올릴 수 있는 비결은 **폐쇄 루프 설계**에 있다.

그의 시스템에서 AI 에이전트는 스스로 컴파일하고, 린팅하고, 실행하고, 검증한다. 사람이 중간에 확인할 필요가 없다. 결과물이 기준을 통과하면 자동으로 다음 단계로 넘어간다. 실패하면 자동으로 재시도한다.

이 시스템이 작동하려면 **AI가 중간에 질문하지 않아야 한다**. 계획 단계에서 모든 불확실성을 제거해야 한다. 그래서 Steinberger는 계획 수립에 많은 시간을 쏟는다. 에이전트와 대화하면서 계획을 다듬고, 충분히 명확해지면 그제서야 실행한다.

Claude Code는 이 시스템과 맞지 않는다. Claude Code는 **사용자 친화적**이다. 불확실한 점이 있으면 질문한다. "이 함수를 수정할까요, 아니면 새로 만들까요?" 같은 질문이다. 대부분의 사용자에게는 유용한 기능이다. 하지만 이미 완벽한 계획을 세워놓은 Steinberger에게는 불필요한 중단이다.

Codex는 다르다. 계획을 받으면 **끝까지 실행한다**. 중간에 질문하지 않는다. 결과가 나오면 던져준다. 이 방식이 Steinberger의 폐쇄 루프 시스템에 맞다.

The Pragmatic Engineer의 Gergely Orosz는 이렇게 정리했다.

> "Peter는 계획 수립에 많은 시간을 쓴다. Codex를 선호하는 이유는 Codex가 장시간 작업을 알아서 처리하기 때문이다. Claude Code는 명확화를 위해 질문을 던지는데, 이미 계획을 다 세운 상태에서는 방해가 된다."

이건 Claude Code의 단점이 아니다. **다른 사용 패턴에 최적화된 것**이다. 계획 없이 AI와 협업하면서 결과물을 만들어가는 사용자에게는 Claude Code의 질문이 도움이 된다. 하지만 계획을 완벽하게 세우고 비동기로 실행하는 사용자에게는 Codex가 맞다.

---

## OpenClaw 성공의 비밀: 모델을 가리지 않는다

OpenClaw가 GitHub 역사상 가장 빠르게 성장할 수 있었던 이유 중 하나는 **모델 종속성이 없다**는 점이다.

많은 AI 도구들이 특정 모델에 묶여 있다. Claude Code는 Claude 모델만 쓴다. GitHub Copilot은 OpenAI 모델 기반이다. 사용자는 선택권이 없다.

OpenClaw는 다르다. 사용자가 원하는 모델을 선택할 수 있다. Claude Opus 4.6, GPT Codex 5.3, DeepSeek V4, Gemini 3 Pro, 심지어 로컬에서 돌리는 Llama 3.2까지 지원한다. 자신의 API 키를 연결하면 된다.

이 설계 철학은 Steinberger 본인의 경험에서 나왔다. 그는 Opus가 최고라고 생각하지만, 자신은 Codex를 쓴다. 이 경험이 OpenClaw의 모델 애그노스틱 설계로 이어졌다.

OpenClaw GitHub 저장소에는 이런 문구가 있다.

> "AI/vibe-coded PRs welcome!"

바이브 코딩으로 기여한 코드도 환영한다는 뜻이다. OpenClaw 자체가 바이브 코딩으로 만들어졌으니, 기여자들도 바이브 코딩을 쓸 수 있다.

이 개방성이 OpenClaw의 폭발적 성장에 기여했다. 18만 스타, 6,600개의 월간 커밋. 한 사람이 만든 프로젝트치고는 믿기 힘든 숫자다. 하지만 그 "한 사람"은 AI와 함께 일한다. 그리고 그 AI는 사용자가 선택할 수 있다.

---

## Meta와 OpenAI의 러브콜

OpenClaw의 성공은 빅테크의 관심을 끌었다. 2026년 2월, Meta와 OpenAI 양쪽에서 Steinberger에게 제안이 들어왔다.

TrendingTopics.eu의 보도에 따르면, 두 회사 모두 Steinberger를 영입하거나 OpenClaw 프로젝트와의 협력을 타진했다. 구체적인 내용은 공개되지 않았지만, OpenClaw가 업계에 미친 영향력을 보여주는 사례다.

YC(Y Combinator)의 인터뷰에서 Steinberger는 대담한 예측을 했다.

> "미래에는 80%의 앱이 사라질 것이다."

AI 에이전트가 사용자를 대신해서 작업을 수행하면, 기존 앱의 상당수가 필요 없어진다는 뜻이다. 항공권 예약 앱? AI 에이전트가 알아서 예약한다. 음식 배달 앱? AI 에이전트가 주문한다. 앱은 AI 에이전트와 소통하는 API만 남는다.

이 비전이 실현되려면 AI 에이전트가 충분히 똑똑해야 한다. 그리고 Steinberger는 Claude Opus가 그 역할에 가장 적합하다고 본다. 범용 에이전트로서의 안정성, 보안, 긴 컨텍스트 처리 능력 때문이다.

하지만 그런 에이전트를 **만드는** 작업에는 Codex가 낫다. 대량의 코드를 병렬로 생성하고, 테스트하고, 배포하는 작업이니까. 이 구분이 Steinberger 철학의 핵심이다.

---

## AI 코딩 도구 선택의 기준

이 사례에서 우리가 배울 수 있는 건 뭘까?

**첫째, 벤치마크를 맹신하지 마라.**

Terminal-Bench에서 몇 % 차이가 났다고 해서 그게 당신의 작업에 동일하게 적용되지 않는다. 벤치마크는 참고 자료일 뿐이다. 실제로 써보고 자신의 작업에 맞는지 확인해야 한다.

**둘째, 자신의 작업 흐름을 파악하라.**

당신은 AI와 어떻게 일하는가?
- 대화하면서 점진적으로 결과물을 만들어가는가?
- 계획을 먼저 세우고 한 번에 실행시키는가?
- 여러 작업을 병렬로 돌리는가?
- 단일 작업에 집중하는가?

이 질문에 대한 답이 최적의 도구를 결정한다.

**셋째, 작업별로 다른 도구를 써도 된다.**

Opus 4.6으로 설계를 하고, Codex 5.3으로 구현하고, Sonnet 4.5로 일상적인 질문에 답하는 것도 전략이다. 하나의 도구에 올인할 필요 없다.

**넷째, 최고는 계속 바뀐다.**

2026년 2월 5일에 두 회사가 동시에 신모델을 출시했다. 6개월 뒤에는 또 판이 바뀔 것이다. 특정 모델에 너무 종속되면 유연성을 잃는다. 모델 애그노스틱한 접근이 장기적으로 유리하다.

---

## 결론: 모순 속의 통찰

Peter Steinberger는 Claude Opus를 최고의 범용 에이전트라고 말하면서 Codex로 OpenClaw를 만들었다. 이건 모순이 아니다. **가장 정교한 도구 선택**이다.

범용성과 특수성은 다르다. 대중적 추천과 개인적 선택은 다르다. 벤치마크 점수와 실제 작업 적합성은 다르다.

AI 모델을 선택할 때, "뭐가 최고야?"라고 묻지 마라. **"나는 어떻게 일하고, 이 작업에 뭐가 맞아?"**라고 물어야 한다.

18만 스타의 남자가 남긴 진짜 교훈은 이거다. 최고의 도구는 당신이 어떻게 쓰느냐에 달렸다.

---

## 모델 전쟁의 승자는 누구인가

Claude Opus 4.6과 GPT Codex 5.3의 경쟁은 2026년 AI 업계의 가장 흥미로운 구도 중 하나다. 두 모델이 같은 날 출시되었다. 서로를 의식한 타이밍이다.

벤치마크에서는 분야별로 승자가 갈린다. Terminal-Bench에서는 Codex가 앞서고, Humanity's Last Exam에서는 Opus가 앞선다. 처리량에서는 Codex가 4배 빠르고, 긴 컨텍스트 일관성에서는 Opus가 강하다.

하지만 진짜 승자는 **사용자**다. 두 회사가 경쟁하면서 모델 성능이 빠르게 올라가고 있다. Opus 4.6은 Codex의 정밀함을 일부 흡수했고, Codex 5.3은 Opus의 대화 능력을 일부 가져왔다. 서로의 장점을 학습하는 중이다.

OpenClaw 같은 모델 애그노스틱 도구가 인기를 끄는 것도 이 맥락에서 이해된다. 사용자는 경쟁의 수혜자가 되고 싶다. 특정 모델에 묶이면 선택권을 잃는다. OpenClaw는 사용자에게 선택권을 돌려준다.

Steinberger의 조언은 결국 이거다. 모델 전쟁의 승자를 예측하려 하지 마라. **어떤 모델이든 쓸 수 있는 시스템을 만들어라.** 최고는 계속 바뀐다. 유연성이 장기적인 승리다.

---

**출처:**

- [OpenAI launches Codex app to bring its coding models, used to build OpenClaw, to more users — Fortune](https://fortune.com/2026/02/02/openai-launches-codex-app-to-bring-coding-models-to-more-users-openclaw-ai-agents/)
- [The creator of Clawd: "I ship code I don't read" — The Pragmatic Engineer](https://newsletter.pragmaticengineer.com/p/the-creator-of-clawd-i-ship-code)
- [#491 – OpenClaw: The Viral AI Agent that Broke the Internet - Peter Steinberger — Lex Fridman Podcast](https://lexfridman.com/peter-steinberger)
- [GPT-5.3 Codex vs. Opus 4.6: The Great Convergence — Every.to](https://every.to/vibe-check/codex-vs-opus)
- [Claude Opus 4.6 vs GPT-5.3-Codex: Which AI is Best for Coding? — VERTU](https://vertu.com/ai-tools/claude-opus-4-6-vs-gpt-5-3-codex-the-2026-ai-coding-showdown/)
- [OpenClaw GitHub Repository](https://github.com/openclaw/openclaw)
- [Peter Steinberger on X — @steipete](https://x.com/steipete)
- [Unsplash — 이미지 출처](https://unsplash.com)
